// ALLOWS ANYONE TO SEARCH FOR TEMPLATES
// IF NO PARAMS ARE GIVEN RETURNS ALL TEMPLATES

import { PrismaClient } from "@prisma/client";
const prisma = new PrismaClient();

export default async function handler(req, res) {
	if (req.method === "GET") {
		let { search, page, limit } = req.query;
		page = Number(page) || 1; // default page is 1
		limit = Number(limit) || 10; // default limit is 10
		const offset = (page - 1) * limit;
		// CHECK IF ANYTHIGN WAS INCLUDED IN THE SEARCH
		// IF NOT THEN RETURN ALL TEMPLATES
		try {
			if (!search) {
				const templates = await prisma.template.findMany({
					skip: offset,
					take: limit,
				});

				const totalCount = await prisma.template.count();
				return res.status(200).json({
					data: templates,
					totalCount: totalCount,
					page: page,
					limit: limit,
				});
			}
			

			// IF SOMETHING WAS INCLUDED IN THE SEARCH THEN SEARCH FOR IT
			// CHECK FOR SEARCHIN THE TITLE, EXPLANATION, CODE, AND TAGS

			// THIS NEXT PART WAS AUTO GENERATED BY GITHUB COPILOT
			const parsedSearch = parseInt(search, 10); // Explicitly parse search as an integer

			let orConditions = [
				{
					title: {
						contains: search,
					},
				},
				{
					explanation: {
						contains: search,
					},
				},
				{
					code: {
						contains: search,
					},
				},
				{
					tags: {
						contains: search,
					},
				},
			];

			// Check if parsedSearch is a valid number (not NaN)
			if (!isNaN(parsedSearch)) {
				orConditions = [
					{
						userId: {
							equals: parsedSearch, // Use parsed integer here
						},
					}
					
				];
			}

			const templates = await prisma.template.findMany({
				where: {
					OR: orConditions,
				},
				skip: offset,
				take: limit,
			});
			const totalCount = await prisma.template.count({
				where: {
					OR: orConditions,
					/*
					OR: [
						{
							title: {
								contains: search,
							},
						},
						{
							explanation: {
								contains: search,
							},
						},
						{
							code: {
								contains: search,
							},
						},
						{
							tags: {
								contains: search,
							},
						},
					],
					*/
				},
			});

			return res.status(200).json({
				data: templates,
				totalCount: totalCount,
				page: page,
				limit: limit,
			});
		} catch (error) {
			console.error("Detailed error:", error);
			return res
				.status(500)
				.json({ message: "Internal server error", error: error.message });
		}
	} else {
		res.status(405).json({ message: "Method not allowed" });
	}
}
// modified